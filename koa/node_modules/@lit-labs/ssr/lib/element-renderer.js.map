{"version":3,"file":"element-renderer.js","sourceRoot":"","sources":["../src/lib/element-renderer.ts"],"names":[],"mappings":"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","sourcesContent":["/// <reference lib=\"dom\" />\n\n/**\n * @license\n * Copyright 2019 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {escapeHtml} from './util/escape-html.js';\nimport type {RenderInfo} from './render-value.js';\nimport type {RenderResult} from './render-result.js';\n\ntype Interface<T> = {\n  [P in keyof T]: T[P];\n};\n\nexport type ElementRendererConstructor = (new (\n  tagName: string\n) => Interface<ElementRenderer>) &\n  typeof ElementRenderer;\n\ntype AttributesMap = Map<string, string>;\n\nexport const getElementRenderer = (\n  {elementRenderers}: RenderInfo,\n  tagName: string,\n  ceClass: typeof HTMLElement | undefined = customElements.get(tagName),\n  attributes: AttributesMap = new Map()\n): ElementRenderer => {\n  if (ceClass === undefined) {\n    console.warn(`Custom element ${tagName} was not registered.`);\n    return new FallbackRenderer(tagName);\n  }\n  // TODO(kschaaf): Should we implement a caching scheme, e.g. keyed off of\n  // ceClass's base class to prevent O(n) lookups for every element (probably\n  // not a concern for the small number of element renderers we'd expect)? Doing\n  // so would preclude having cross-cutting renderers to e.g. no-op render all\n  // custom elements with a `client-only` attribute, so punting for now.\n  for (const renderer of elementRenderers) {\n    if (renderer.matchesClass(ceClass, tagName, attributes)) {\n      return new renderer(tagName);\n    }\n  }\n  return new FallbackRenderer(tagName);\n};\n\n// TODO (justinfagnani): remove in favor of ShadowRootInit\n/**\n * @deprecated Use ShadowRootInit instead\n */\nexport type ShadowRootOptions = ShadowRootInit;\n\n/**\n * An object that renders elements of a certain type.\n */\nexport abstract class ElementRenderer {\n  // TODO (justinfagnani): We shouldn't assume that ElementRenderer subclasses\n  // create an element instance. Move this to a base class for renderers that\n  // do.\n  element?: HTMLElement;\n  tagName: string;\n\n  /**\n   * Should be implemented to return true when the given custom element class\n   * and/or tagName should be handled by this renderer.\n   *\n   * @param ceClass - Custom Element class\n   * @param tagName - Tag name of custom element instance\n   * @param attributes - Map of attribute key/value pairs\n   * @returns\n   */\n  static matchesClass(\n    _ceClass: typeof HTMLElement,\n    _tagName: string,\n    _attributes: AttributesMap\n  ) {\n    return false;\n  }\n\n  /**\n   * Called when a custom element is instantiated during a server render.\n   *\n   * An ElementRenderer can actually instantiate the custom element class, or\n   * it could emulate the element in some other way.\n   */\n  constructor(tagName: string) {\n    this.tagName = tagName;\n  }\n\n  /**\n   * Called when a custom element is \"attached\" to the server DOM.\n   *\n   * Because we don't presume a full DOM emulation, this isn't the same as\n   * being connected in a real browser. There may not be an owner document,\n   * parentNode, etc., depending on the DOM emulation.\n   *\n   * If this renderer is creating actual element instances, it may forward\n   * the call to the element's `connectedCallback()`.\n   *\n   * The default impementation is a no-op.\n   */\n  connectedCallback(): void {\n    // do nothing\n  }\n\n  /**\n   * Called from `setAttribute()` to emulate the browser's\n   * `attributeChangedCallback` lifecycle hook.\n   *\n   * If this renderer is creating actual element instances, it may forward\n   * the call to the element's `attributeChangedCallback()`.\n   */\n  attributeChangedCallback(\n    _name: string,\n    _old: string | null,\n    _value: string | null\n  ) {\n    // do nothing\n  }\n\n  /**\n   * Handles setting a property on the element.\n   *\n   * The default implementation sets the property on the renderer's element\n   * instance.\n   *\n   * @param name Name of the property\n   * @param value Value of the property\n   */\n  setProperty(name: string, value: unknown) {\n    if (this.element !== undefined) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (this.element as any)[name] = value;\n    }\n  }\n\n  /**\n   * Handles setting an attribute on an element.\n   *\n   * Default implementation calls `setAttribute` on the renderer's element\n   * instance, and calls the abstract `attributeChangedCallback` on the\n   * renderer.\n   *\n   * @param name Name of the attribute\n   * @param value Value of the attribute\n   */\n  setAttribute(name: string, value: string) {\n    // Browser turns all HTML attributes to lowercase.\n    name = name.toLowerCase();\n    if (this.element !== undefined) {\n      const old = this.element.getAttribute(name);\n      this.element.setAttribute(name, value);\n      this.attributeChangedCallback(name, old, value);\n    }\n  }\n\n  /**\n   * The shadow root options to write to the declarative shadow DOM <template>,\n   * if one is created with `renderShadow()`.\n   */\n  get shadowRootOptions(): ShadowRootInit {\n    return {mode: 'open'};\n  }\n\n  /**\n   * Render the element's shadow root children.\n   *\n   * If `renderShadow()` returns undefined, no declarative shadow root is\n   * emitted.\n   */\n  renderShadow(_renderInfo: RenderInfo): RenderResult | undefined {\n    return undefined;\n  }\n\n  /**\n   * Render the element's light DOM children.\n   */\n  renderLight(_renderInfo: RenderInfo): RenderResult | undefined {\n    return undefined;\n  }\n\n  /**\n   * Render the element's attributes.\n   *\n   * The default implementation serializes all attributes on the element\n   * instance.\n   */\n  *renderAttributes(): RenderResult {\n    if (this.element !== undefined) {\n      const {attributes} = this.element;\n      for (\n        let i = 0, name, value;\n        i < attributes.length && ({name, value} = attributes[i]);\n        i++\n      ) {\n        if (value === '' || value === undefined || value === null) {\n          yield ` ${name}`;\n        } else {\n          yield ` ${name}=\"${escapeHtml(value)}\"`;\n        }\n      }\n    }\n  }\n}\n\n/**\n * An ElementRenderer used as a fallback in the case where a custom element is\n * either unregistered or has no other matching renderer.\n */\nexport class FallbackRenderer extends ElementRenderer {\n  private readonly _attributes: {[name: string]: string} = {};\n\n  override setAttribute(name: string, value: string) {\n    // Browser turns all HTML attributes to lowercase.\n    this._attributes[name.toLowerCase()] = value;\n  }\n\n  override *renderAttributes(): RenderResult {\n    for (const [name, value] of Object.entries(this._attributes)) {\n      if (value === '' || value === undefined || value === null) {\n        yield ` ${name}`;\n      } else {\n        yield ` ${name}=\"${escapeHtml(value)}\"`;\n      }\n    }\n  }\n}\n"]}