{"version":3,"file":"render-result-readable.js","sourceRoot":"","sources":["../src/lib/render-result-readable.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AAEH,OAAO,EAAC,QAAQ,EAAC,MAAM,QAAQ,CAAC;AAKhC;;GAEG;AACH,MAAM,OAAO,oBAAqB,SAAQ,QAAQ;IAsBhD,YAAY,MAAoB;QAC9B,KAAK,EAAE,CAAC;QAXV;;;;;;;WAOG;QACK,aAAQ,GAAG,KAAK,CAAC;QAIvB,IAAI,CAAC,OAAO,GAAG,MAAM,CAAC;QACtB,IAAI,CAAC,UAAU,GAAG,CAAC,IAAI,CAAC,OAAO,CAAC,MAAM,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;IACtD,CAAC;IAEQ,KAAK,CAAC,KAAK,CAAC,KAAa;QAChC,IAAI,IAAI,CAAC,QAAQ,EAAE,CAAC;YAClB,OAAO;QACT,CAAC;QACD,yEAAyE;QACzE,mEAAmE;QACnE,sCAAsC;QACtC,uEAAuE;QACvE,oCAAoC;QACpC,mEAAmE;QACnE,iBAAiB;QACjB,EAAE;QACF,mEAAmE;QACnE,8BAA8B;QAC9B,EAAE;QACF,6CAA6C;QAC7C,oEAAoE;QACpE,qEAAqE;QACrE,mCAAmC;QACnC,sCAAsC;QACtC,EAAE;QACF,sEAAsE;QACtE,sEAAsE;QACtE,0CAA0C;QAE1C,uEAAuE;QACvE,2BAA2B;QAC3B,IAAI,CAAC,gBAAgB,KAAK,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;QAEhD,OAAO,IAAI,CAAC,gBAAgB,KAAK,SAAS,EAAE,CAAC;YAC3C,MAAM,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,EAAE,CAAC;YAC1C,IAAI,IAAI,CAAC,IAAI,KAAK,IAAI,EAAE,CAAC;gBACvB,6BAA6B;gBAC7B,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC;gBAC9C,SAAS;YACX,CAAC;YAED,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC;YAEzB,IAAI,OAAO,KAAK,KAAK,QAAQ,EAAE,CAAC;gBAC9B,IAAI,IAAI,CAAC,IAAI,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,CAAC;oBAC/B,gEAAgE;oBAChE,mCAAmC;oBACnC,OAAO;gBACT,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,oBAAoB;gBACpB,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,gBAAgB,CAAC,CAAC;gBAC5C,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;gBACrB,IAAI,CAAC,gBAAgB,GAAG,CAAC,MAAM,KAAK,CAAC,CACnC,MAAM,CAAC,QAAQ,CAChB,EAA0B,CAAC;gBAC5B,IAAI,CAAC,QAAQ,GAAG,KAAK,CAAC;YACxB,CAAC;QACH,CAAC;QACD,iCAAiC;QACjC,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;IAClB,CAAC;CACF","sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n\nimport {Readable} from 'stream';\nimport {RenderResult} from './render-result.js';\n\ntype RenderResultIterator = Iterator<string | Promise<RenderResult>>;\n\n/**\n * A Readable that reads from a RenderResult.\n */\nexport class RenderResultReadable extends Readable {\n  private _result: RenderResult;\n\n  /**\n   * A stack of open iterators.\n   *\n   * We need to keep this as instance state because we can pause and resume\n   * reading values at any time and can't guarantee to run iterators to\n   * completion in any one loop.\n   */\n  private _iterators: Array<RenderResultIterator>;\n  private _currentIterator?: RenderResultIterator;\n  /**\n   * `_waiting` flag is used to prevent multiple concurrent reads.\n   *\n   * RenderResultReadable handles async RenderResult's, and must await them.\n   * While awaiting a result, it's possible for `_read` to be called again.\n   * Without this flag, a new read is initiated and the order of the data in the\n   * stream becomes inconsistent.\n   */\n  private _waiting = false;\n\n  constructor(result: RenderResult) {\n    super();\n    this._result = result;\n    this._iterators = [this._result[Symbol.iterator]()];\n  }\n\n  override async _read(_size: number) {\n    if (this._waiting) {\n      return;\n    }\n    // This implementation reads values from the RenderResult and pushes them\n    // into the base class's Readable implementation. It tries to be as\n    // efficient as possible, which means:\n    //   1. Avoid microtasks and Promise allocations. Read and write values\n    //      synchronously when possible.\n    //   2. Write as many values to the Readable per call to _read() as\n    //      possible.\n    //\n    // To do this correctly we must adhere to the Readable contract for\n    // _read(), which states that:\n    //\n    // - The size parameter can be safely ignored\n    // - _read() should call `this.push()` as many times as it can until\n    //   `this.push()` returns false, which means the underlying Readable\n    //   does not want any more values.\n    // - `this.push(null)` ends the stream\n    //\n    // This means that we cannot use for/of loops to iterate on the render\n    // result, because we must be able to return in the middle of the loop\n    // and resume on the next call to _read().\n\n    // Get the current iterator, only if we don't already have one from the\n    // previous call to _read()\n    this._currentIterator ??= this._iterators.pop();\n\n    while (this._currentIterator !== undefined) {\n      const next = this._currentIterator.next();\n      if (next.done === true) {\n        // Restore the outer iterator\n        this._currentIterator = this._iterators.pop();\n        continue;\n      }\n\n      const value = next.value;\n\n      if (typeof value === 'string') {\n        if (this.push(value) === false) {\n          // The consumer doesn't want any more values. Return for now and\n          // we may get a new call to _read()\n          return;\n        }\n      } else {\n        // Must be a Promise\n        this._iterators.push(this._currentIterator);\n        this._waiting = true;\n        this._currentIterator = (await value)[\n          Symbol.iterator\n        ]() as RenderResultIterator;\n        this._waiting = false;\n      }\n    }\n    // Pushing `null` ends the stream\n    this.push(null);\n  }\n}\n"]}